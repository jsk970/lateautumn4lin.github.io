<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git生态探索之Commit message和Change log编写最佳实践</title>
      <link href="/2019/08/28/git-sheng-tai-tan-suo-zhi-commit-message-he-change-log-bian-xie-zui-jia-shi-jian/"/>
      <url>/2019/08/28/git-sheng-tai-tan-suo-zhi-commit-message-he-change-log-bian-xie-zui-jia-shi-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近在学习规范如何使用<code>git</code>来更高效的开发，发现一个比较好用的来规范<code>comment</code>的工具，所以想来记录一下。一般来说，<code>commit message</code> 应该清晰明了，说明本次提交的目的。所以需要一些规范来使这些<code>comment</code>变得可读，<code>commitizen</code>则是最近发现的一款比较易用的工具。</p><p><code>git</code>的提交一般的初学者都会使用<code>git commit -m "hello world"</code>来提交<code>comment</code>，但是一些像<code>hello world</code>这样没有意义的<code>comment</code>让人无法理解这次的提交到底是为了什么，所以我们就要规范一下<code>comment</code>的规范了。</p><pre><code>PS:下面是一些基础介绍如果大佬请直接查看第二部分</code></pre><h1 id="1-commit-message-format-信息域"><a href="#1-commit-message-format-信息域" class="headerlink" title="1. commit message format(信息域)"></a>1. commit message format(信息域)</h1><p><em><em>commit message一般分为三个部分</em>Header，Body 和 Footer</em></p><pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// 空一行&lt;body&gt;// 空一行&lt;footer&gt;其中，Header 是必需的，Body 和 Footer 可以省略Example:PS D:\git\pythonPractice&gt; git logcommit 58a7a966acb9aa2fffc0e02c9ce3be64b8949991 (HEAD -&gt; master)Author: Zhiwei Tian &lt;hebeitianzhiwei@outlook.com&gt;Date:   Fri Aug 17 17:38:36 2018 +0800    feat(serve): add grpc server</code></pre><hr><h2 id="1-1-HEAD"><a href="#1-1-HEAD" class="headerlink" title="1.1 HEAD"></a>1.1 HEAD</h2><ul><li><code>type</code>用于说明 <code>commit</code> 的类别，只允许使用下面7个标识</li></ul><pre><code>feat：新功能（feature）fix：修补bugdocs：文档（documentation）style： 格式（不影响代码运行的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）test：增加测试chore：构建过程或辅助工具的变动</code></pre><ul><li><code>scope</code> 用来说明本次Commit影响的范围，即简要说明修改会涉及的部分,比如数据层、控制层、视图层等,</li><li><code>subject</code>comment所在的位置,这次提交的简短描述</li></ul><hr><h2 id="1-2-Body-是对本次-commit-的详细描述，可以分成多行"><a href="#1-2-Body-是对本次-commit-的详细描述，可以分成多行" class="headerlink" title="1.2 Body 是对本次 commit 的详细描述，可以分成多行"></a>1.2 Body 是对本次 commit 的详细描述，可以分成多行</h2><h2 id="1-3-Footer-部分只用于两种情况"><a href="#1-3-Footer-部分只用于两种情况" class="headerlink" title="1.3 Footer 部分只用于两种情况"></a>1.3 Footer 部分只用于两种情况</h2><ul><li>不兼容变动</li></ul><blockquote><p>如果当前代码与上一个版本不兼容，则 <code>Footer</code> 部分以<code>BREAKING CHANGE</code>开头，后面是对变动的描述、以及变动理由和迁移方法</p></blockquote><ul><li>关闭 Issue</li></ul><blockquote><p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue (可依次关闭过个issue<code>Closes #123, #245, #992</code>)</p></blockquote><h2 id="1-4-Revert"><a href="#1-4-Revert" class="headerlink" title="1.4 Revert"></a>1.4 Revert</h2><p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header</p><pre><code>revert: type(scope):  some commentThis reverts commit bfe307ce57d87677c6c473c228e6c2ed8b81dcec.</code></pre><p>Body部分的格式是固定的，必须写成<code>This reverts commit &amp;lt;hash&gt;.</code>，其中的hash是被撤销 commit 的 <code>HSHA</code> 标识符。<br>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面</p><h1 id="2-使用commitizen来执行规范"><a href="#2-使用commitizen来执行规范" class="headerlink" title="2. 使用commitizen来执行规范"></a>2. 使用commitizen来执行规范</h1><p>因为<code>commitizen</code>是<code>node</code>的模块，所以前提需要安装<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">node</a>(官网下载地址)</p><ol><li>全局安装<code>commitizen</code>node模块</li></ol><pre><code>npm install -g commitizen</code></pre><ol start="2"><li>在项目目录下运行命令</li></ol><pre><code>commitizen init cz-conventional-changelog --save --save-exact</code></pre><ol start="3"><li>此时可能会报找不到<code>package.json</code>的错误,使用下面命令来自动生成一个项目的package,然后在运行<strong>2</strong>中的命令.</li></ol><pre><code>npm init --yes</code></pre><p>运行完以上一律使用<code>git cz</code> 代替<code>git commit</code>来提交代码,同时会显示一下选项来自动生成符合格式的commit message.</p><pre><code>PS D:\git\pythonPractice&gt; git czcz-cli@2.10.1, cz-conventional-changelog@2.1.0Line 1 will be cropped at 100 characters. All other lines will be wrapped after 100 characters.? Select the type of change that you're committing: (Use arrow keys)&gt; feat:     A new feature  fix:      A bug fix  docs:     Documentation only changes  style:    Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)  refactor: A code change that neither fixes a bug nor adds a feature  perf:     A code change that improves performance  test:     Adding missing tests or correcting existing tests(Move up and down to reveal more choices)</code></pre><p>按照提示,你可以写出规范的message了<br>idea有插件可以使用<a href="https://plugins.jetbrains.com/plugin/9861-git-commit-template" target="_blank" rel="noopener">git commit template</a></p><blockquote><p>commitizen同时可以检查commit message是否符合格式.<br>生成change log,还又一些高级用法比如ghooks<br>这里就不细说了.详细请查看参考链接和<a href="https://github.com/conventional-changelog-archived-repos/validate-commit-msg" target="_blank" rel="noopener">validate-commit-msg</a></p></blockquote><ol start="4"><li>现在项目中可能多出来<code>dir:node_nodules, file:package.json, package-lock.json</code>这些目录和文件,这是node安装模块产生的,如果不是node项目都可以忽略掉,熟悉node的同学肯定都知道哪些是有用的了.</li></ol><blockquote><p>参考链接:<br><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">阮一峰</a>的博客<br><a href="http://jartto.wang/2018/07/08/git-commit/" target="_blank" rel="noopener">Jartto’s blog</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Git生态探索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解K8S的设计精髓之List-Watch机制和Informer模块</title>
      <link href="/2019/08/28/li-jie-k8s-de-she-ji-jing-sui-zhi-list-watch-ji-zhi-he-informer-mo-kuai/"/>
      <url>/2019/08/28/li-jie-k8s-de-she-ji-jing-sui-zhi-list-watch-ji-zhi-he-informer-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>最近想深入了解一下<code>K8S</code>的内部通信机制，因此读了几遍<code>K8S</code>的源码，感慨很深。至今清楚的记得，当了解到<code>K8S</code> 组件之间仅采用<code>HTTP 协议</code>通信，没有依赖<code>中间件</code>时，我非常好奇它是如何做到的。</p><p>在<code>K8S</code> 内部通信中，肯定要保证消息的实时性。之前以为方式有两种：</p><ol><li>客户端组件(<code>kubelet</code>, <code>scheduler</code>, <code>controller-manager</code> 等)轮询 apiserver，</li><li><code>apiserver</code> 通知客户端。<br>如果采用<code>轮询</code>，势必会大大增加 <code>apiserver</code>的压力，同时实时性很低。<br>如果 <code>apiserver</code> 主动发<code>HTTP</code> 请求，又如何保证消息的可靠性，以及大量端口占用问题？</li></ol><p>当阅读完 <code>list-watch</code> 源码后，先是所有的疑惑云开雾散，进而为<code>K8S</code>的<code>设计理念</code>所折服。<code>List-watch</code> 是 <code>K8S</code> 统一的异步消息处理机制，保证了消息的实时性，可靠性，顺序性，性能等等，为声明式风格的<code>API</code> 奠定了良好的基础，它是优雅的通信方式，是 <code>K8S 架构</code>的精髓。</p><h3 id="2-List-Watch-机制具体是什么样的"><a href="#2-List-Watch-机制具体是什么样的" class="headerlink" title="2. List-Watch 机制具体是什么样的"></a>2. List-Watch 机制具体是什么样的</h3><p><code>Etcd</code>存储集群的数据信息，<code>apiserver</code>作为统一入口，任何对数据的操作都必须经过 <code>apiserver</code>。客户端(<code>kubelet</code>/<code>scheduler</code>/<code>controller-manager</code>)通过 <code>list-watch</code> 监听 <code>apiserver</code> 中资源(<code>pod/rs/rc</code>等等)的 <code>create</code>, <code>update</code> 和 <code>delete</code> 事件，并针对<code>事件类型</code>调用相应的<code>事件处理函数</code>。</p><p>那么<code>list-watch</code> 具体是什么呢，顾名思义，<code>list-watch</code>有两部分组成，分别是<code>list</code>和 <code>watch</code>。<code>list</code> 非常好理解，就是调用资源的<code>list API</code>罗列资源，基于<code>HTTP</code>短链接<code>实现；</code>watch<code>则是调用资源的</code>watch API<code>监听资源变更事件，基于</code>HTTP 长链接<code>实现，也是本文重点分析的对象。以</code> pod 资源<code>为例，它的</code> list <code>和</code>watch API <code>分别为：[List API](https://v1-10.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/#list-all-namespaces-63)，返回值为 [PodList](https://v1-10.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/#podlist-v1-core)，即一组</code> pod`。</p><blockquote><p>GET /api/v1/pods</p></blockquote><p><a href="https://v1-10.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/#watch-list-all-namespaces-66" target="_blank" rel="noopener">Watch API</a>，往往带上 <code>watch=true</code>，表示采用 <code>HTTP 长连接</code>持续监听 <code>pod 相关事件</code>，每当有事件来临，返回一个 <a href="https://v1-10.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/#watchevent-v1-meta" target="_blank" rel="noopener">WatchEvent</a>。</p><blockquote><p>GET /api/v1/watch/pods</p></blockquote><p><code>K8S</code> 的<code>informer</code> 模块封装 <code>list-watch API</code>，用户只需要指定资源，编写事件处理函数，<code>AddFunc</code>, <code>UpdateFunc</code>和 <code>DeleteFunc</code>等。如下图所示，<code>informer</code>首先通过<code>list API</code> 罗列资源，然后调用 <code>watch API</code>监听资源的变更事件，并将结果放入到一个 <code>FIFO 队列</code>，队列的另一头有协程从中取出事件，并调用对应的注册函数处理事件。<code>Informer</code>还维护了一个只读的<code>Map Store</code> 缓存，主要为了提升查询的效率，降低<code>apiserver</code> 的负载。</p><p><img src="https://upload-images.jianshu.io/upload_images/3029445-8326e103c0216c83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="listwatch.png"></p><h3 id="3-Watch-是如何实现的"><a href="#3-Watch-是如何实现的" class="headerlink" title="3.Watch 是如何实现的"></a>3.Watch 是如何实现的</h3><p><code>List</code>的实现容易理解，那么 <code>Watch</code> 是如何实现的呢？<code>Watch</code>是如何通过 <code>HTTP 长链接</code>接收<code>apiserver</code>发来的<code>资源变更事件</code>呢？</p><p>秘诀就是 <a href="https://zh.wikipedia.org/zh-hans/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">Chunked transfer encoding(分块传输编码)</a>，它首次出现在<code>HTTP/1.1</code>。正如维基百科所说：</p><blockquote><p>HTTP 分块传输编码允许服务器为动态生成的内容维持 HTTP 持久链接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。使用分块传输编码，数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。</p></blockquote><p>当客户端调用 <code>watch API</code> 时，<code>apiserve</code>r 在<code>response</code> 的 <code>HTTP Header</code> 中设置 <code>Transfer-Encoding</code>的值为<code>chunked</code>，表示采用<code>分块传输</code>编码，客户端收到该信息后，便和服务端该链接，并等待下一个数据块，即资源的事件信息。例如：</p><pre><code>$ curl -i http://{kube-api-server-ip}:8080/api/v1/watch/pods?watch=yesHTTP/1.1 200 OKContent-Type: application/jsonTransfer-Encoding: chunkedDate: Thu, 02 Jan 2019 20:22:59 GMTTransfer-Encoding: chunked{"type":"ADDED", "object":{"kind":"Pod","apiVersion":"v1",...}}{"type":"ADDED", "object":{"kind":"Pod","apiVersion":"v1",...}}{"type":"MODIFIED", "object":{"kind":"Pod","apiVersion":"v1",...}}</code></pre><h3 id="4-谈谈-List-Watch-的设计理念"><a href="#4-谈谈-List-Watch-的设计理念" class="headerlink" title="4. 谈谈 List-Watch 的设计理念"></a>4. 谈谈 List-Watch 的设计理念</h3><p>当设计优秀的一个异步消息的系统时，对<code>消息机制</code>有至少如下四点要求：</p><ul><li>消息可靠性</li><li>消息实时性</li><li>消息顺序性</li><li>高性能</li></ul><p>首先<code>消息</code>必须是<code>可靠</code>的，<code>list</code> 和 <code>watch</code> 一起保证了消息的可靠性，避免因消息丢失而造成状态不一致场景。具体而言，<code>list API</code>可以查询当前的资源及其对应的状态(即期望的状态)，客户端通过拿<code>期望的状态</code>和<code>实际的状态</code>进行对比，纠正状态不一致的资源。<code>Watch API</code> 和 <code>apiserver</code>保持一个<code>长链接</code>，接收资源的<code>状态变更事件</code>并做相应处理。如果仅调用 <code>watch API</code>，若某个时间点连接中断，就有可能导致消息丢失，所以需要通过<code>list API</code>解决<code>消息丢失</code>的问题。从另一个角度出发，我们可以认为<code>list API</code>获取全量数据，<code>watch API</code>获取增量数据。虽然仅仅通过轮询 <code>list API</code>，也能达到同步资源状态的效果，但是存在开销大，实时性不足的问题。</p><p>消息必须是实时的，<code>list-watch</code> 机制下，每当<code>apiserver</code> 的资源产生<code>状态变更事件</code>，都会将事件及时的推送给客户端，从而保证了<code>消息的实时性</code>。</p><p>消息的顺序性也是非常重要的，在并发的场景下，客户端在短时间内可能会收到同一个资源的多个事件，对于<code>关注最终一致性</code>的 <code>K8S</code> 来说，它需要知道哪个是最近发生的事件，并保证资源的最终状态如同最近事件所表述的状态一样。<code>K8S</code> 在每个资源的事件中都带一个 <code>resourceVersion</code>的标签，这个标签是递增的数字，所以当客户端并发处理同一个资源的事件时，它就可以对比 <code>resourceVersion</code>来保证最终的状态和最新的事件所期望的状态保持一致。</p><p><code>List-watch</code> 还具有高性能的特点，虽然仅通过周期性调用<code>list API</code>也能达到资源最终一致性的效果，但是周期性频繁的轮询大大的增大了开销，增加<code>apiserver</code>的压力。而<code>watch</code> 作为异步消息通知机制，复用一条长链接，保证实时性的同时也保证了性能。</p><h3 id="5-Informer介绍"><a href="#5-Informer介绍" class="headerlink" title="5. Informer介绍"></a>5. Informer介绍</h3><p><code>Informer</code> 是 <code>Client-go</code> 中的一个核心工具包。在<code>Kubernetes</code>源码中，如果 <code>Kubernetes</code> 的某个组件，需要 <code>List/Get Kubernetes</code> 中的 <code>Object</code>，在绝大多 数情况下，会直接使用<code>Informer</code>实例中的<code>Lister()</code>方法（该方法包含 了 Get 和 List 方法），而很少直接请求<code>Kubernetes API</code>。<code>Informer</code> 最基本 的功能就是<code>List/Get Kubernetes</code>中的 <code>Object</code>。</p><p>如下图所示，仅需要十行左右的代码就能实现对<code>Pod</code>的<code>List</code> 和 <code>Get</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/3029445-55898dffcef103e3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="informar.jpeg"></p><h3 id="6-Informer-设计思路"><a href="#6-Informer-设计思路" class="headerlink" title="6. Informer 设计思路"></a>6. Informer 设计思路</h3><h4 id="6-1-Informer-设计中的关键点"><a href="#6-1-Informer-设计中的关键点" class="headerlink" title="6.1 Informer 设计中的关键点"></a>6.1 Informer 设计中的关键点</h4><p>为了让<code>Client-go</code> 更快地返回<code>List/Get</code>请求的结果、减少对 <code>Kubenetes API</code>的直接调用，<code>Informer</code> 被设计实现为一个依赖<code>Kubernetes List/Watch API</code>、<code>可监听事件并触发回调函数</code>的<code>二级缓存</code>工具包。</p><h4 id="6-2-更快地返回-List-Get-请求，减少对-Kubenetes-API-的直接调用"><a href="#6-2-更快地返回-List-Get-请求，减少对-Kubenetes-API-的直接调用" class="headerlink" title="6.2 更快地返回 List/Get 请求，减少对 Kubenetes API 的直接调用"></a>6.2 更快地返回 List/Get 请求，减少对 Kubenetes API 的直接调用</h4><p>使用<code>Informer</code>实例的<code>Lister()</code>方法，<code>List/Get Kubernetes</code> 中的 <code>Object</code>时，<code>Informer</code>不会去请求<code>Kubernetes API</code>，而是直接查找<code>缓存</code>在本地内存中的数据(这份数据由<code>Informer</code>自己维护)。通过这种方式，<code>Informer</code>既可以更快地返回结果，又能减少对 <code>Kubernetes API</code> 的直接调用。</p><h4 id="6-3-依赖-Kubernetes-List-Watch-API"><a href="#6-3-依赖-Kubernetes-List-Watch-API" class="headerlink" title="6.3 依赖 Kubernetes List/Watch API"></a>6.3 依赖 Kubernetes List/Watch API</h4><p><code>Informer</code> 只会调用<code>Kubernetes List</code> 和 <code>Watch</code>两种类型的 <code>API</code>。<code>Informer</code>在初始化的时，先调用<code>Kubernetes List API</code> 获得某种 <code>resource</code>的全部<code>Object</code>，缓存在<code>内存</code>中; 然后，调用 <code>Watch API</code> 去<code>watch</code>这种<code>resource</code>，去维护这份缓存; 最后，<code>Informer</code>就不再调用<code>Kubernetes</code>的任何 API。</p><p>用<code>List/Watch</code>去维护缓存、保持一致性是非常典型的做法，但令人费解的是，<code>Informer</code> 只在初始化时调用一次<code>List API</code>，之后完全依赖 <code>Watch API</code>去维护缓存，没有任何<code>resync</code>机制。</p><p>笔者在阅读<code>Informer</code>代码时候，对这种做法十分不解。按照多数人思路，通过 <code>resync</code>机制，重新<code>List</code>一遍 <code>resource</code>下的所有<code>Object</code>，可以更好的保证 <code>Informer 缓存</code>和 <code>Kubernetes</code> 中数据的一致性。</p><p>咨询过<code>Google</code> 内部 <code>Kubernetes</code>开发人员之后，得到的回复是:</p><p>在 <code>Informer</code> 设计之初，确实存在一个<code>relist</code>无法去执 <code>resync</code>操作， 但后来被取消了。原因是现有的这种 <code>List/Watch</code> 机制，完全能够保证永远不会漏掉任何事件，因此完全没有必要再添加<code>relist</code>方法去<code>resync informer</code>的缓存。这种做法也说明了<code>Kubernetes</code>完全信任<code>etcd</code>。</p><h4 id="6-4-可监听事件并触发回调函数"><a href="#6-4-可监听事件并触发回调函数" class="headerlink" title="6.4 可监听事件并触发回调函数"></a>6.4 可监听事件并触发回调函数</h4><p><code>Informer</code>通过<code>Kubernetes Watch API</code>监听某种 <code>resource</code>下的所有事件。而且，<code>Informer</code>可以添加自定义的回调函数，这个回调函数实例(即 <code>ResourceEventHandler</code> 实例)只需实现 <code>OnAdd</code>(obj interface{}) <code>OnUpdate</code>(oldObj, newObj interface{}) 和<code>OnDelete</code>(obj interface{}) 三个方法，这三个方法分别对应<code>informer</code>监听到<code>创建</code>、<code>更新</code>和<code>删除</code>这三种事件类型。</p><p>在<code>Controller</code>的设计实现中，会经常用到 <code>informer</code>的这个功能。</p><h4 id="6-5-二级缓存"><a href="#6-5-二级缓存" class="headerlink" title="6.5 二级缓存"></a>6.5 二级缓存</h4><p>二级缓存属于 <code>Informer</code>的底层缓存机制，这两级缓存分别是<code>DeltaFIFO</code>和 <code>LocalStore</code>。</p><p>这两级缓存的用途各不相同。<code>DeltaFIFO</code>用来存储<code>Watch API</code>返回的各种事件 ，<code>LocalStore</code> 只会被<code>Lister</code>的<code>List/Get</code>方法访问 。</p><p>虽然<code>Informer</code>和 <code>Kubernetes</code> 之间没有<code>resync</code>机制，但<code>Informer</code>内部的这两级缓存之间存在<code>resync</code> 机制。</p><h4 id="6-6-关键逻辑介绍"><a href="#6-6-关键逻辑介绍" class="headerlink" title="6.6 关键逻辑介绍"></a>6.6 关键逻辑介绍</h4><p><img src="https://upload-images.jianshu.io/upload_images/3029445-df5ccf0817266fdb.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.jpeg"></p><p><img src="https://upload-images.jianshu.io/upload_images/3029445-818499c747eb2550.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.jpeg"></p><p><img src="https://upload-images.jianshu.io/upload_images/3029445-2420d7f16b85e554.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.jpeg"></p><ol><li><p>Informer 在初始化时，Reflector 会先 List API 获得所有的 Pod</p></li><li><p>Reflect 拿到全部 Pod 后，会将全部 Pod 放到 Store 中</p></li><li><p>如果有人调用 Lister 的 List/Get 方法获取 Pod， 那么 Lister 会直接从 Store 中拿数据</p></li><li><p>Informer 初始化完成之后，Reflector 开始 Watch Pod，监听 Pod 相关 的所有事件;如果此时 pod_1 被删除，那么 Reflector 会监听到这个事件</p></li><li><p>Reflector 将 pod_1 被删除 的这个事件发送到 DeltaFIFO</p></li><li><p>DeltaFIFO 首先会将这个事件存储在自己的数据结构中(实际上是一个 queue)，然后会直接操作 Store 中的数据，删除 Store 中的 pod_1</p></li><li><p>DeltaFIFO 再 Pop 这个事件到 Controller 中</p></li><li><p>Controller 收到这个事件，会触发 Processor 的回调函数</p></li><li><p>LocalStore 会周期性地把所有的 Pod 信息重新放到 DeltaFIFO 中</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 解读K8S源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
            <tag> Go </tag>
            
            <tag> List-Watch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>透过真实场景分析K8S的EndpointController的源码</title>
      <link href="/2019/08/28/tou-guo-zhen-shi-chang-jing-fen-xi-k8s-de-endpointcontroller-de-yuan-ma/"/>
      <url>/2019/08/28/tou-guo-zhen-shi-chang-jing-fen-xi-k8s-de-endpointcontroller-de-yuan-ma/</url>
      
        <content type="html"><![CDATA[<h3 id="场景重现"><a href="#场景重现" class="headerlink" title="场景重现"></a>场景重现</h3><p>最近遇到一个问题，在<code>K8S</code>的几台机器上中创建了<code>Glusterfs</code>的集群，通过官方的教程一步步的来利用<code>Glusterfs</code>创建<code>Volume</code>以及<code>PV</code>，不过只是创建了每个<code>Volume</code>的<code>Endpoint</code>，并没有相对应的创建<code>Service</code>实例（官方说创建<code>Service</code>会使<code>Endpoint</code>持久化，当时并没有理会），然后在一次集群重启的时候发现<code>Endpoint</code>实例并没有启动起来，很疑惑，像其他的<code>K8S</code>对象，例如<code>POD</code>，<code>Deployment</code>，<code>Service</code>都启动起来了，但是<code>Endpoint</code>并没有，带着这个问题看了下官方的<code>Issue</code>，并没有什么有效的解答，大家可以参考一下<a href="[https://github.com/kubernetes/kubernetes/issues/12964](https://github.com/kubernetes/kubernetes/issues/12964)">Issue: </a><a href="https://github.com/kubernetes/kubernetes/issues/12964" target="_blank" rel="noopener">Endpoints are not persistented</a></p><h3 id="1-探究源码"><a href="#1-探究源码" class="headerlink" title="1. 探究源码"></a>1. 探究源码</h3><h4 id="1-1-源码版本"><a href="#1-1-源码版本" class="headerlink" title="1.1 源码版本"></a>1.1 源码版本</h4><ul><li>基于k8s release-1.13</li></ul><h4 id="1-2-源码目录结构"><a href="#1-2-源码目录结构" class="headerlink" title="1.2 源码目录结构"></a>1.2 源码目录结构</h4><p>由于我们重点看<code>Endpoint</code>部分，因此我们只看<code>Endpoint</code>相关的源码<br><img src="https://upload-images.jianshu.io/upload_images/3029445-ac22778f75c458be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Endpoint"></p><h4 id="1-3-Endpoint的初始化"><a href="#1-3-Endpoint的初始化" class="headerlink" title="1.3 Endpoint的初始化"></a>1.3 Endpoint的初始化</h4><p>文件位置： <code>endpoints_controller.go</code></p><pre class="line-numbers language-golang"><code class="language-golang">// NewEndpointController returns a new *EndpointController.//我们可以看到在Endpoint初始化的时候，已经注册了三个informer，分别是podInformer，serviceInformer，endpointsInformerfunc NewEndpointController(podInformer coreinformers.PodInformer, serviceInformer coreinformers.ServiceInformer,    endpointsInformer coreinformers.EndpointsInformer, client clientset.Interface) *EndpointController {    broadcaster := record.NewBroadcaster()    broadcaster.StartLogging(klog.Infof)    broadcaster.StartRecordingToSink(&v1core.EventSinkImpl{Interface: client.CoreV1().Events("")})    recorder := broadcaster.NewRecorder(scheme.Scheme, v1.EventSource{Component: "endpoint-controller"})    if client != nil && client.CoreV1().RESTClient().GetRateLimiter() != nil {        metrics.RegisterMetricAndTrackRateLimiterUsage("endpoint_controller", client.CoreV1().RESTClient().GetRateLimiter())    }    e := &EndpointController{        client:           client,        queue:            workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "endpoint"),        workerLoopPeriod: time.Second,    }        //这里对service进行watch操作，并注册了对应的add\update\del等操作    serviceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{//add：以添加的service的namespace/name形式为key，并将该key加入 queue        AddFunc: e.enqueueService,//update：以更新后的service的namespace/name形式为key，并将该key加入 queue        UpdateFunc: func(old, cur interface{}) {            e.enqueueService(cur)        },//delete：以删除的service的namespace/name形式为key，并将该key加入 queue        DeleteFunc: e.enqueueService,    })    e.serviceLister = serviceInformer.Lister()    e.servicesSynced = serviceInformer.Informer().HasSynced        //这里对pod进行watch操作，并注册了对应的add\update\del等操作    podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{        AddFunc:    e.addPod,        UpdateFunc: e.updatePod,        DeleteFunc: e.deletePod,    })    e.podLister = podInformer.Lister()    e.podsSynced = podInformer.Informer().HasSynced    e.endpointsLister = endpointsInformer.Lister()    e.endpointsSynced = endpointsInformer.Informer().HasSynced    e.triggerTimeTracker = NewTriggerTimeTracker()    e.eventBroadcaster = broadcaster    e.eventRecorder = recorder    return e}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看看<code>pod</code>注册的<code>Handler</code>引用了哪些函数</p><h5 id="1-3-1-e-addPod"><a href="#1-3-1-e-addPod" class="headerlink" title="1.3.1 e.addPod"></a>1.3.1 e.addPod</h5><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>EndpointController<span class="token punctuation">)</span> <span class="token function">addPod</span><span class="token punctuation">(</span>obj <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//实例化一个pod对象</span>    pod <span class="token operator">:=</span> obj<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">)</span>    services<span class="token punctuation">,</span> err <span class="token operator">:=</span> e<span class="token punctuation">.</span><span class="token function">getPodServiceMemberships</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        utilruntime<span class="token punctuation">.</span><span class="token function">HandleError</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Unable to get pod %s/%s's service memberships: %v"</span><span class="token punctuation">,</span> pod<span class="token punctuation">.</span>Namespace<span class="token punctuation">,</span> pod<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//将service集合以namespace/name为key逐个加入到queue中</span>    <span class="token keyword">for</span> key <span class="token operator">:=</span> <span class="token keyword">range</span> services <span class="token punctuation">{</span>        e<span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>EndpointController<span class="token punctuation">)</span> <span class="token function">getPodServiceMemberships</span><span class="token punctuation">(</span>pod <span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">)</span> <span class="token punctuation">(</span>sets<span class="token punctuation">.</span>String<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    set <span class="token operator">:=</span> sets<span class="token punctuation">.</span>String<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//获取pod与service的映射关系</span>    services<span class="token punctuation">,</span> err <span class="token operator">:=</span> e<span class="token punctuation">.</span>serviceLister<span class="token punctuation">.</span><span class="token function">GetPodServices</span><span class="token punctuation">(</span>pod<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// don't log this error because this function makes pointless</span>        <span class="token comment" spellcheck="true">// errors when no services match.</span>        <span class="token keyword">return</span> set<span class="token punctuation">,</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//查找逻辑为逐个对比service的selector与该pod的label，如果service的selector为该pod label的子集，则表示该pod属于service</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> services <span class="token punctuation">{</span>        key<span class="token punctuation">,</span> err <span class="token operator">:=</span> controller<span class="token punctuation">.</span><span class="token function">KeyFunc</span><span class="token punctuation">(</span>services<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err        <span class="token punctuation">}</span>        set<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> set<span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-2-e-updatePod"><a href="#1-3-2-e-updatePod" class="headerlink" title="1.3.2 e.updatePod"></a>1.3.2 e.updatePod</h5><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>EndpointController<span class="token punctuation">)</span> <span class="token function">updatePod</span><span class="token punctuation">(</span>old<span class="token punctuation">,</span> cur <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    newPod <span class="token operator">:=</span> cur<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">)</span>    oldPod <span class="token operator">:=</span> old<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//比较两者的ResourceVersion，对比更新后的pod与原pod，如果两者的资源版本相等，则直接返回，不进行入队操作</span>    <span class="token keyword">if</span> newPod<span class="token punctuation">.</span>ResourceVersion <span class="token operator">==</span> oldPod<span class="token punctuation">.</span>ResourceVersion <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Periodic resync will send update events for all known pods.</span>        <span class="token comment" spellcheck="true">// Two different versions of the same pod will always have different RVs.</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//判断pod相关信息是否发生改变</span>    podChangedFlag <span class="token operator">:=</span> <span class="token function">podChanged</span><span class="token punctuation">(</span>oldPod<span class="token punctuation">,</span> newPod<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// Check if the pod labels have changed, indicating a possible</span>    <span class="token comment" spellcheck="true">// change in the service membership</span>    labelsChanged <span class="token operator">:=</span> <span class="token boolean">false</span><span class="token comment" spellcheck="true">//判断两者的label是否已经不一致，或者hostname或subdomain已改变</span>    <span class="token keyword">if</span> <span class="token operator">!</span>reflect<span class="token punctuation">.</span><span class="token function">DeepEqual</span><span class="token punctuation">(</span>newPod<span class="token punctuation">.</span>Labels<span class="token punctuation">,</span> oldPod<span class="token punctuation">.</span>Labels<span class="token punctuation">)</span> <span class="token operator">||</span>        <span class="token operator">!</span><span class="token function">hostNameAndDomainAreEqual</span><span class="token punctuation">(</span>newPod<span class="token punctuation">,</span> oldPod<span class="token punctuation">)</span> <span class="token punctuation">{</span>        labelsChanged <span class="token operator">=</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// If both the pod and labels are unchanged, no update is needed</span>    <span class="token keyword">if</span> <span class="token operator">!</span>podChangedFlag <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>labelsChanged <span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//判断错误，则获取对应的service和pod映射关系</span>    services<span class="token punctuation">,</span> err <span class="token operator">:=</span> e<span class="token punctuation">.</span><span class="token function">getPodServiceMemberships</span><span class="token punctuation">(</span>newPod<span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        utilruntime<span class="token punctuation">.</span><span class="token function">HandleError</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Unable to get pod %v/%v's service memberships: %v"</span><span class="token punctuation">,</span> newPod<span class="token punctuation">.</span>Namespace<span class="token punctuation">,</span> newPod<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> labelsChanged <span class="token punctuation">{</span>        oldServices<span class="token punctuation">,</span> err <span class="token operator">:=</span> e<span class="token punctuation">.</span><span class="token function">getPodServiceMemberships</span><span class="token punctuation">(</span>oldPod<span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            utilruntime<span class="token punctuation">.</span><span class="token function">HandleError</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Unable to get pod %v/%v's service memberships: %v"</span><span class="token punctuation">,</span> oldPod<span class="token punctuation">.</span>Namespace<span class="token punctuation">,</span> oldPod<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        services <span class="token operator">=</span> <span class="token function">determineNeededServiceUpdates</span><span class="token punctuation">(</span>oldServices<span class="token punctuation">,</span> services<span class="token punctuation">,</span> podChangedFlag<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> key <span class="token operator">:=</span> <span class="token keyword">range</span> services <span class="token punctuation">{</span>        e<span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">podChanged</span><span class="token punctuation">(</span>oldPod<span class="token punctuation">,</span> newPod <span class="token operator">*</span>v1<span class="token punctuation">.</span>Pod<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//podChanged函数，其检测逻辑为，如果新旧两个pod的DeletionTimestamp字段不等则返回true，否则继续判断两者的就绪状态，如果不等则返回true，最后再判断新旧pod的ip、nodename、namespace、UID是否相等，如果相等则返回false，否则返回true。将返回结果赋值给podChangedFlag</span>    <span class="token comment" spellcheck="true">// If the pod's deletion timestamp is set, remove endpoint from ready address.</span>    <span class="token keyword">if</span> newPod<span class="token punctuation">.</span>DeletionTimestamp <span class="token operator">!=</span> oldPod<span class="token punctuation">.</span>DeletionTimestamp <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// If the pod's readiness has changed, the associated endpoint address</span>    <span class="token comment" spellcheck="true">// will move from the unready endpoints set to the ready endpoints.</span>    <span class="token comment" spellcheck="true">// So for the purposes of an endpoint, a readiness change on a pod</span>    <span class="token comment" spellcheck="true">// means we have a changed pod.</span>    <span class="token keyword">if</span> podutil<span class="token punctuation">.</span><span class="token function">IsPodReady</span><span class="token punctuation">(</span>oldPod<span class="token punctuation">)</span> <span class="token operator">!=</span> podutil<span class="token punctuation">.</span><span class="token function">IsPodReady</span><span class="token punctuation">(</span>newPod<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Convert the pod to an EndpointAddress, clear inert fields,</span>    <span class="token comment" spellcheck="true">// and see if they are the same.</span>    newEndpointAddress <span class="token operator">:=</span> <span class="token function">podToEndpointAddress</span><span class="token punctuation">(</span>newPod<span class="token punctuation">)</span>    oldEndpointAddress <span class="token operator">:=</span> <span class="token function">podToEndpointAddress</span><span class="token punctuation">(</span>oldPod<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// Ignore the ResourceVersion because it changes</span>    <span class="token comment" spellcheck="true">// with every pod update. This allows the comparison to</span>    <span class="token comment" spellcheck="true">// show equality if all other relevant fields match.</span>    newEndpointAddress<span class="token punctuation">.</span>TargetRef<span class="token punctuation">.</span>ResourceVersion <span class="token operator">=</span> <span class="token string">""</span>    oldEndpointAddress<span class="token punctuation">.</span>TargetRef<span class="token punctuation">.</span>ResourceVersion <span class="token operator">=</span> <span class="token string">""</span>    <span class="token keyword">if</span> reflect<span class="token punctuation">.</span><span class="token function">DeepEqual</span><span class="token punctuation">(</span>newEndpointAddress<span class="token punctuation">,</span> oldEndpointAddress<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// The pod has not changed in any way that impacts the endpoints</span>        <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-Endpoint-Controller具体逻辑"><a href="#1-4-Endpoint-Controller具体逻辑" class="headerlink" title="1.4 Endpoint-Controller具体逻辑"></a>1.4 Endpoint-Controller具体逻辑</h4><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// Run will not return until stopCh is closed. workers determines how many</span><span class="token comment" spellcheck="true">// endpoints will be handled in parallel.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>EndpointController<span class="token punctuation">)</span> <span class="token function">Run</span><span class="token punctuation">(</span>workers <span class="token builtin">int</span><span class="token punctuation">,</span> stopCh <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">defer</span> utilruntime<span class="token punctuation">.</span><span class="token function">HandleCrash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> e<span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">ShutDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    klog<span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Starting endpoint controller"</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> klog<span class="token punctuation">.</span><span class="token function">Infof</span><span class="token punctuation">(</span><span class="token string">"Shutting down endpoint controller"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 等待pod、service、endpoint列表同步</span>    <span class="token keyword">if</span> <span class="token operator">!</span>controller<span class="token punctuation">.</span><span class="token function">WaitForCacheSync</span><span class="token punctuation">(</span><span class="token string">"endpoint"</span><span class="token punctuation">,</span> stopCh<span class="token punctuation">,</span> e<span class="token punctuation">.</span>podsSynced<span class="token punctuation">,</span> e<span class="token punctuation">.</span>servicesSynced<span class="token punctuation">,</span> e<span class="token punctuation">.</span>endpointsSynced<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 这里workers数为kube-controller-manager启动参数中的--concurrent-endpoint-syncs决定，默认为5，workerLoopPeriod为1秒</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> workers<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 执行worker函数，for死循环处理queue中的key</span>        <span class="token keyword">go</span> wait<span class="token punctuation">.</span><span class="token function">Until</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>worker<span class="token punctuation">,</span> e<span class="token punctuation">.</span>workerLoopPeriod<span class="token punctuation">,</span> stopCh<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">defer</span> utilruntime<span class="token punctuation">.</span><span class="token function">HandleCrash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        e<span class="token punctuation">.</span><span class="token function">checkLeftoverEndpoints</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&lt;-</span>stopCh<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>EndpointController<span class="token punctuation">)</span> <span class="token function">worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> e<span class="token punctuation">.</span><span class="token function">processNextWorkItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>EndpointController<span class="token punctuation">)</span> <span class="token function">processNextWorkItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>    eKey<span class="token punctuation">,</span> quit <span class="token operator">:=</span> e<span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> quit <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> e<span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span>eKey<span class="token punctuation">)</span>    err <span class="token operator">:=</span> e<span class="token punctuation">.</span><span class="token function">syncService</span><span class="token punctuation">(</span>eKey<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    e<span class="token punctuation">.</span><span class="token function">handleErr</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> eKey<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>endpointController的主要逻辑在<code>syncService</code>函数</p><pre><code>func (e *EndpointController) syncService(key string) error {    startTime := time.Now()    defer func() {        klog.V(4).Infof("Finished syncing service %q endpoints. (%v)", key, time.Since(startTime))    }() // 根据key获取service的namespace和name    namespace, name, err := cache.SplitMetaNamespaceKey(key)    if err != nil {        return err    }    service, err := e.serviceLister.Services(namespace).Get(name)    if err != nil { // 如果service已经被删除，则也要删除对用的endpoint资源        // Delete the corresponding endpoint, as the service has been deleted.        // TODO: Please note that this will delete an endpoint when a        // service is deleted. However, if we're down at the time when        // the service is deleted, we will miss that deletion, so this        // doesn't completely solve the problem. See #6877.        err = e.client.CoreV1().Endpoints(namespace).Delete(name, nil)        if err != nil &amp;&amp; !errors.IsNotFound(err) {            return err        }        e.triggerTimeTracker.DeleteEndpoints(namespace, name)        return nil    }    // 如果service的.spec.selector字段为空，直接返回，endpointController不处理这种情况    if service.Spec.Selector == nil {        // services without a selector receive no endpoints from this controller;        // these services will receive the endpoints that are created out-of-band via the REST API.        return nil    }    klog.V(5).Infof("About to update endpoints for service %q", key)    pods, err := e.podLister.Pods(service.Namespace).List(labels.Set(service.Spec.Selector).AsSelectorPreValidated())    if err != nil {        // Since we're getting stuff from a local cache, it is        // basically impossible to get this error.        return err    }    // If the user specified the older (deprecated) annotation, we have to respect it.    tolerateUnreadyEndpoints := service.Spec.PublishNotReadyAddresses    //如果service的注解含有key为service.alpha.kubernetes.io/tolerate-unready-endpoints的值，该值为bool类型，默认tolerateUnreadyEndpoints值为false    if v, ok := service.Annotations[TolerateUnreadyEndpointsAnnotation]; ok {        b, err := strconv.ParseBool(v)        if err == nil {            tolerateUnreadyEndpoints = b        } else {            utilruntime.HandleError(fmt.Errorf("Failed to parse annotation %v: %v", TolerateUnreadyEndpointsAnnotation, err))        }    }    // We call ComputeEndpointsLastChangeTriggerTime here to make sure that the state of the trigger    // time tracker gets updated even if the sync turns out to be no-op and we don't update the    // endpoints object.    endpointsLastChangeTriggerTime := e.triggerTimeTracker.        ComputeEndpointsLastChangeTriggerTime(namespace, name, service, pods)    subsets := []v1.EndpointSubset{}    var totalReadyEps int    var totalNotReadyEps int    //循环处理pod列表    for _, pod := range pods {        // pod的podIp为空，则continue for循环        if len(pod.Status.PodIP) == 0 {            klog.V(5).Infof("Failed to find an IP for pod %s/%s", pod.Namespace, pod.Name)            continue        }        // 如果该pod正在被删除，则continue for循环        if !tolerateUnreadyEndpoints &amp;&amp; pod.DeletionTimestamp != nil { // 获取该pod的信息，输出EndpointAddress结构体变量            klog.V(5).Infof("Pod is being deleted %s/%s", pod.Namespace, pod.Name)            continue        }        epa := *podToEndpointAddress(pod)        hostname := pod.Spec.Hostname        // 如果pod存在hostname，则最后的FQDN为hostname.subdomain.namespace.svc.cluster.local        if len(hostname) &gt; 0 &amp;&amp; pod.Spec.Subdomain == service.Name &amp;&amp; service.Namespace == pod.Namespace {            epa.Hostname = hostname        }        // Allow headless service not to have ports.        // 允许headless service没有端口        if len(service.Spec.Ports) == 0 {            if service.Spec.ClusterIP == api.ClusterIPNone {  // 1、如果tolerateUnreadyEndpoints为true，允许未就绪的pod也列入Addresses列表，如果tolerateUnreadyEndpoints为false但pod状态为ready则将pod列入Addresses列表;                // 2、检测pod的重启策略，如果重启策略为Never，pod的运行状态不为Failed且不是Succeeded，将该pod列入NotReadyAddresses，如果重启策略为OnFailure并且pod的运行状态不为Succeeded，将该pod列入NotReadyAddresses，其它情况也将该pod列入NotReadyAddresses；                subsets, totalReadyEps, totalNotReadyEps = addEndpointSubset(subsets, pod, epa, nil, tolerateUnreadyEndpoints)                // No need to repack subsets for headless service without ports.            }        } else {            //　循环service的ports端口            for i := range service.Spec.Ports {                servicePort := &amp;service.Spec.Ports[i]                portName := servicePort.Name                portProto := servicePort.Protocol                portNum, err := podutil.FindPort(pod, servicePort)                // 如果service中的port在pod中不存在，则继续for循环                if err != nil {                    klog.V(4).Infof("Failed to find port for service %s/%s: %v", service.Namespace, service.Name, err)                    continue                }                var readyEps, notReadyEps int                epp := &amp;v1.EndpointPort{Name: portName, Port: int32(portNum), Protocol: portProto}                subsets, readyEps, notReadyEps = addEndpointSubset(subsets, pod, epa, epp, tolerateUnreadyEndpoints)                totalReadyEps = totalReadyEps + readyEps                totalNotReadyEps = totalNotReadyEps + notReadyEps            }        }    }    // 重新整理subsets    subsets = endpoints.RepackSubsets(subsets)    // 如果endpoint不存在(通常该情况是新建一个service的情况)，则新建一个，如果是其他未知错误，则返回err    // See if there's actually an update here.    currentEndpoints, err := e.endpointsLister.Endpoints(service.Namespace).Get(service.Name)    if err != nil {        if errors.IsNotFound(err) {            currentEndpoints = &amp;v1.Endpoints{                ObjectMeta: metav1.ObjectMeta{                    Name:   service.Name,                    Labels: service.Labels,                },            }        } else {            return err        }    }    // currentEndpoints的资源版本为空时，表示要创建endpoint    createEndpoints := len(currentEndpoints.ResourceVersion) == 0    // 如果当前currentEndpoints的subset列表和重新整理后的subsets相等，并且label与service的label一致，则忽略本次更新操作    if !createEndpoints &amp;&amp;        apiequality.Semantic.DeepEqual(currentEndpoints.Subsets, subsets) &amp;&amp;        apiequality.Semantic.DeepEqual(currentEndpoints.Labels, service.Labels) {        klog.V(5).Infof("endpoints are equal for %s/%s, skipping update", service.Namespace, service.Name)        return nil    }    newEndpoints := currentEndpoints.DeepCopy()    newEndpoints.Subsets = subsets    newEndpoints.Labels = service.Labels    if newEndpoints.Annotations == nil {        newEndpoints.Annotations = make(map[string]string)    }    if !endpointsLastChangeTriggerTime.IsZero() {        newEndpoints.Annotations[v1.EndpointsLastChangeTriggerTime] =            endpointsLastChangeTriggerTime.Format(time.RFC3339Nano)    } else { // No new trigger time, clear the annotation.        delete(newEndpoints.Annotations, v1.EndpointsLastChangeTriggerTime)    }    klog.V(4).Infof("Update endpoints for %v/%v, ready: %d not ready: %d", service.Namespace, service.Name, totalReadyEps, totalNotReadyEps)    if createEndpoints {        // 如果没有与service同命名空间和同名的endpoint，则生成新的endpoint        // No previous endpoints, create them        _, err = e.client.CoreV1().Endpoints(service.Namespace).Create(newEndpoints)    } else {        // Pre-existing        // 已经存在与service同命名空间和同名的endpoint，需要更新endpoint        _, err = e.client.CoreV1().Endpoints(service.Namespace).Update(newEndpoints)    }    if err != nil {        if createEndpoints &amp;&amp; errors.IsForbidden(err) {            // A request is forbidden primarily for two reasons:            // 1. namespace is terminating, endpoint creation is not allowed by default.            // 2. policy is misconfigured, in which case no service would function anywhere.            // Given the frequency of 1, we log at a lower level.            klog.V(5).Infof("Forbidden from creating endpoints: %v", err)        }        if createEndpoints {            e.eventRecorder.Eventf(newEndpoints, v1.EventTypeWarning, "FailedToCreateEndpoint", "Failed to create endpoint for service %v/%v: %v", service.Namespace, service.Name, err)        } else {            e.eventRecorder.Eventf(newEndpoints, v1.EventTypeWarning, "FailedToUpdateEndpoint", "Failed to update endpoint %v/%v: %v", service.Namespace, service.Name, err)        }        return err    }    return nil}</code></pre><h4 id="1-5-Endpoint检测"><a href="#1-5-Endpoint检测" class="headerlink" title="1.5 Endpoint检测"></a>1.5 Endpoint检测</h4><p>之前说的是当<code>Endpoint</code>和<code>Service</code>绑定的时候<code>Service</code>和<code>Pod</code>改变时的一系列操作，现在我们回到问题，如果<code>Endpoint</code>单独存在，<code>K8S</code>是如何检测并且删除的？<br>我们重新看看<code>Run</code>函数中的</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">defer</span> utilruntime<span class="token punctuation">.</span><span class="token function">HandleCrash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        e<span class="token punctuation">.</span><span class="token function">checkLeftoverEndpoints</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>K8S</code>在运行<code>Run</code>函数的时候启动了一个协程去检测当前所有的<code>Endpoint</code></p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// checkLeftoverEndpoints lists all currently existing endpoints and adds their</span><span class="token comment" spellcheck="true">// service to the queue. This will detect endpoints that exist with no</span><span class="token comment" spellcheck="true">// corresponding service; these endpoints need to be deleted. We only need to</span><span class="token comment" spellcheck="true">// do this once on startup, because in steady-state these are detected (but</span><span class="token comment" spellcheck="true">// some stragglers could have been left behind if the endpoint controller</span><span class="token comment" spellcheck="true">// reboots).</span><span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>EndpointController<span class="token punctuation">)</span> <span class="token function">checkLeftoverEndpoints</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//拉取当前所有的endpoint对象</span>    list<span class="token punctuation">,</span> err <span class="token operator">:=</span> e<span class="token punctuation">.</span>endpointsLister<span class="token punctuation">.</span><span class="token function">List</span><span class="token punctuation">(</span>labels<span class="token punctuation">.</span><span class="token function">Everything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        utilruntime<span class="token punctuation">.</span><span class="token function">HandleError</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Unable to list endpoints (%v); orphaned endpoints will not be cleaned up. (They're pretty harmless, but you can restart this component if you want another attempt made.)"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//轮询所有endpoint</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ep <span class="token operator">:=</span> <span class="token keyword">range</span> list <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> ep<span class="token punctuation">.</span>Annotations<span class="token punctuation">[</span>resourcelock<span class="token punctuation">.</span>LeaderElectionRecordAnnotationKey<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// when there are multiple controller-manager instances,</span>            <span class="token comment" spellcheck="true">// we observe that it will delete leader-election endpoints after 5min</span>            <span class="token comment" spellcheck="true">// and cause re-election</span>            <span class="token comment" spellcheck="true">// so skip the delete here</span>            <span class="token comment" spellcheck="true">// as leader-election only have endpoints without service</span>            <span class="token keyword">continue</span>        <span class="token punctuation">}</span>        key<span class="token punctuation">,</span> err <span class="token operator">:=</span> controller<span class="token punctuation">.</span><span class="token function">KeyFunc</span><span class="token punctuation">(</span>ep<span class="token punctuation">)</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            utilruntime<span class="token punctuation">.</span><span class="token function">HandleError</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"Unable to get key for endpoint %#v"</span><span class="token punctuation">,</span> ep<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">continue</span>        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//假如此处endpoint没有对应的service，猜想会把endpoint的name当成key传入queue，然后在之前的逻辑中判断获取service name错误，于是删除endpoint</span>        e<span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h3><p>一句话，遇到如上问题有两种解决的方式：</p><ol><li>创建<code>Service</code>的时候使用<code>Selector</code>，这样可以自动创建<code>Endpoint</code></li><li>在创建<code>Endpoint</code>还需要创建<code>Service</code>，这样才可以持久化<code>Endpoint</code></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 解读K8S源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
